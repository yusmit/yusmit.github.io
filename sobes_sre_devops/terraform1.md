# Часть 1: Базовые концепции (Must Know)

#### 1. Что такое Terraform и его основная философия?
*   **Terraform** — это инструмент для безопасного и эффективного построения, изменения и управления инфраструктурой в виде кода (Infrastructure as Code, IaC). Он использует декларативный подход.
*   **Декларативный подход vs Императивный:** Вы описываете *желаемое состояние* инфраструктуры ("мне нужно 2 виртуальные машины"), а не шаги для его достижения ("создай одну ВМ, потом вторую"). Terraform сам вычисляет, как перейти из текущего состояния в желаемое.

#### 2. Основные компоненты Terraform
*   **`terraform` CLI:** Основная утилита для управления всем жизненным циклом.
*   **Конфигурационные файлы (`*.tf`):** Файлы, где вы описываете свою инфраструктуру на языке json (HashiCorp Configuration Language) или JSON.
*   **Провайдер (Provider):** Плагины, которые взаимодействуют с API облачных провайдеров (AWS, Azure, GCP), платформ (Kubernetes) и сервисов (Datadog, Cloudflare). Определяются в блоке `provider`.
    ```json
    provider "aws" {
      region = "us-west-2"
    }
    ```
*   **Ресурс (Resource):** Основной элемент инфраструктуры (например, виртуальная машина, сеть, bucket S3). Описывается блоком `resource`.
    ```json
    resource "aws_instance" "example" {
      ami           = "ami-0c55b159cbfafe1f0"
      instance_type = "t2.micro"
    }
    ```
*   **Модуль (Module):** Контейнер для множества ресурсов, которые используются вместе. Позволяет инкапсулировать и переиспользовать код.
*   **Переменная (Variable):** Параметры, которые делают ваш код гибким и переиспользуемым. Определяются блоком `variable`.
*   **Вывод (Output):** Значения, которые возвращает ваша конфигурация (например, public IP созданной ВМ). Определяются блоком `output`.

#### 3. Жизненный цикл Terraform (Основные команды)
1.  `terraform init`: Инициализирует рабочий каталог, скачивает необходимые провайдеры и модули.
2.  `terraform plan`: Создает "план исполнения". Показывает, что *будет* сделано для приведения инфраструктуры к желаемому состоянию. **Безопасная команда, ничего не меняет.**
3.  `terraform apply`: Применяет изменения, предложенные планом. Фактически создает, изменяет или удаляет ресурсы.
4.  `terraform destroy`: Уничтожает все ресурсы, управляемые данной конфигурацией.

#### 4. Состояние (State)
*   **Что такое `terraform.tfstate`?** Это JSON-файл, который хранит полное текущее состояние вашей инфраструктуры (ID ресурсов, их свойства и зависимости). Это "источник правды" для Terraform.
*   **Почему это важно?** Terraform использует state для сравнения с вашим кодом и понимания, какие изменения необходимо применить.
*   **Проблемы с локальным state:** Нельзя использовать в команде, риск потери файла.
*   **Решение: Remote Backend.** Хранение state файла в удаленном, общем хранилище (S3, Azure Storage, GCS) с блокировкой (State Locking) для предотвращения конфликтов при одновременном `apply`.

---

# Часть 2: Продвинутые концепции (Часто спрашивают на мид/сеньор уровня)

#### 1. Управление State на практике
*   **State Locking:** Механизм предотвращения одновременных операций `apply` для одного state (через DynamoDB для AWS, Blob Storage для Azure). Предотвращает повреждение state.
*   **`terraform state` команды:**
    *   `terraform state list` - показать все ресурсы в state.
    *   `terraform state show <resource>` - показать атрибуты конкретного ресурса.
    *   `terraform state rm <resource>` - удалить ресурс из управления Terraform (ресурс в облаке НЕ удаляется).
    *   `terraform import <resource> <id>` - импортировать *существующую* инфраструктуру под управление Terraform. **Очень важная и частая задача в реальной жизни.**

#### 2. Вопросы про `plan` и `apply`
*   **Что происходит при запуске `terraform plan`?**
    1.  Terraform читает текущий state файл.
    2.  Читает все файлы `.tf` в директории.
    3.  Сравнивает желаемое состояние (код) с актуальным (state).
    4.  Строит граф зависимостей ресурсов.
    5.  Формирует план изменений (diff).
*   **Можно ли применить план, сохраненный с помощью `terraform plan -out=plan.tfplan`?** Да, с помощью `terraform apply plan.tfplan`. Это гарантирует, что будут применены именно те изменения, которые вы видели в плане.

#### 3. Модули: создание и использование
*   **Зачем нужны?** Переиспользование кода, организация, абстракция сложности, соблюдение принципа DRY (Don't Repeat Yourself).
*   **Структура модуля:** Любая папка с файлами `.tf`. Условно делятся на:
    *   **Корневой модуль (Root Module):** Главная конфигурация.
    *   **Дочерние модули (Child Modules):** Вызываются из корневого через блок `module`.
    ```json
    module "vpc" {
      source  = "terraform-aws-modules/vpc/aws"
      version = "3.14.0" # всегда указывать версию!

      name = "my-vpc"
      cidr = "10.0.0.0/16"
      # ... остальные параметры
    }
    ```
*   **Источники модулей (source):** Локальный путь, Git, HTTP, S3 bucket и др.

#### 4. Работа с динамическими данными и зависимостями
*   **Data Sources (`data`):** Позволяют получать информацию о ресурсах, *не управляемых* текущей конфигурацией Terraform (например, прочитать AMI ID, созданный вручную).
    ```json
    data "aws_ami" "latest_ubuntu" {
      most_recent = true
      owners      = ["099720109477"] # Canonical

      filter {
        name   = "name"
        values = ["ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*"]
      }
    }

    # Использование
    resource "aws_instance" "example" {
      ami           = data.aws_ami.latest_ubuntu.id # ссылаемся на data source
      instance_type = "t2.micro"
    }
    ```
*   **Явные и неявные зависимости:**
    *   **Неявная:** Terraform автоматически определяет зависимости через ссылки в коде (например, `aws_instance.example.subnet_id` создает зависимость от `aws_subnet.main`).
    *   **Явная:** Иногда зависимость не видна в коде. Используется мета-аргумент `depends_on`.
        ```json
        resource "aws_instance" "example" {
          # ...
          depends_on = [aws_iam_role_policy.example] # явно говорим ждать создания политики IAM
        }
        ```

#### 5. Управление версиями провайдеров и Terraform
*   **`required_providers`:** Блок в котором указываются используемые провайдеры и их версии.
*   **`required_version`:** Ограничение на версию самого Terraform.
*   **Версионирование (`~>`, `>=` и т.д.):**
    ```json
    terraform {
      required_version = ">= 1.0" # любая версия 1.x и выше

      required_providers {
        aws = {
          source  = "hashicorp/aws"
          version = "~> 4.0" # версия 4.x (4.0, 4.1, 4.2...), но не 5.0
        }
      }
    }
    ```

---

# Часть 3: Вопросы на проектирование и лучшие практики

1.  **Как вы организуете структуру проектов для `dev`/`stage`/`prod`?**
    *   **Вариант 1: Разные каталоги** (рекомендуемый HashiCorp). Для каждого окружения своя папка со своими настройками (variables, backend), но общими модулями.
    *   **Вариант 2: Terraform Workspaces.** Легче начать, но state для всех окружений хранится в одном бэкенде, что может быть рискованно. Не рекомендуется для серьезных проектов с сильно отличающимися окружениями.

2.  **Как обеспечить безопасность (секреты, ключи доступа)?**
    *   **Никогда не хранить секреты в коде или в state файле в открытом виде!**
    *   Использовать переменные окружения (`TF_VAR_<variable_name>`).
    *   Использовать интеграцию с секрет-менеджерами (AWS Secrets Manager, Azure Key Vault, HashiCorp Vault) через data sources.
    *   Бэкенд (например, S3) должен быть защищен и шифроваться.

3.  **Как организовать совместную работу команды?**
    *   Remote Backend с блокировкой.
    *   Код в Git.
    *   Проверка кода через Code Review (Pull Request).
    *   Запуск `plan` и `apply` через CI/CD пайплайн (например, GitLab CI, GitHub Actions, Atlantis). **Человек не должен иметь прямых доступов к облаку, все изменения только через пайплайн.**

4.  **Что такое `terraform fmt`, `validate`, `tflint`?**
    *   `fmt` — приводит код к каноническому виду и стилю.
    *   `validate` — проверяет синтаксическую правильность кода.
    *   `tflint` — линтер, который находит потенциальные ошибки и несоответствия best practices.

**"Вы запустили `terraform apply`, и он завис на создании одного ресурса на долгое время. Ваши действия?"**

**Ответ:**
1.  Первое — **не паниковать и не прерывать процесс (Ctrl+C)**. Это может привести к непредсказуемому состоянию ресурса.
2.  Проверить логи и статус ресурса непосредственно в облачной консоли (AWS Console, Azure Portal). Часто проблема видна там (квота, недоступность зоны).
3.  Если понятно, что ресурс "завис" навсегда (например, таймаут API), можно аккуратно прервать `apply`.
4.  Запустить `terraform plan` чтобы увидеть, в каком состоянии Terraform видит инфраструктуру. Скорее всего, он предложит доставить ресурс.
5.  Если ресурс был частично создан, его, возможно, придется очистить вручную через консоль или пометить для `terraform import` и затем `terraform destroy`.
