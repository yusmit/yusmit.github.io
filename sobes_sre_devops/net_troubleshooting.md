# **Таблица траблшутинга**
Вот **расширенная таблица** с инструментами для траблшутинга сети, включая **ключевые показатели** для анализа:  

| Категория               | Инструмент          | На что обращать внимание                                                                 | Пример команды                                                                 |
|-------------------------|---------------------|-----------------------------------------------------------------------------------------|--------------------------------------------------------------------------------|
| **Проверка подключения** | `ping`             | **Loss%** (потеря пакетов), **RTT** (задержка), **TTL** (достижимость)                 | `ping -c 5 google.com`                                                         |
|                         | `traceroute`/`mtr` | **Пропущенные хопы**, **высокий RTT на конкретном узле**, **потери пакетов**           | `mtr -n google.com`                                                            |
|                         | `dig`/`nslookup`   | **Ответ DNS** (`ANSWER SECTION`), **время запроса**, **NXDOMAIN** (несуществующий домен)| `dig +short google.com`                                                        |
| **Анализ трафика**       | `tcpdump`          | **SYN без ACK** (блокировка), **повторные передачи**, **неожиданные RST**               | `sudo tcpdump -i eth0 'tcp and host 8.8.8.8'`                                  |
|                         | `Wireshark`/`tshark` | **SSL-ошибки**, **коды HTTP**, **фрагментация пакетов**, **retransmissions**           | `tshark -i eth0 -Y "http.request"`                                             |
|                         | `ngrep`            | **Подозрительные HTTP-запросы**, **незашифрованные данные**                             | `sudo ngrep -d eth0 'password' port 80`                                        |
| **Соединения**           | `ss`               | **LISTEN** (открытые порты), **ESTAB** (активные подключения), **TIME-WAIT** (зависшие)| `ss -tulnp \| grep 443`                                                        |
|                         | `lsof`             | **Процесс, занявший порт**, **неожиданные открытые файлы/сокеты**                       | `sudo lsof -i :80`                                                             |
| **Нагрузка**            | `iftop`            | **Топ "пожирателей" трафика**, **неожиданные IP**, **асимметрия входящего/исходящего**  | `sudo iftop -i eth0 -P`                                                        |
|                         | `nload`            | **Необычные скачки скорости**, **перегрузка интерфейса**                                | `nload eth0 -u M` (в МБ/с)                                                     |
|                         | `iperf3`           | **Пропускная способность**, **jitter**, **потери пакетов**                              | `iperf3 -c 192.168.1.1 -t 30`                                                  |
| **Маршрутизация**        | `tcptraceroute`    | **Блокировка ICMP**, **проблемные узлы** (высокий RTT/DROP)                             | `tcptraceroute -n -p 443 google.com`                                           |
|                         | `hping3`           | **Фильтрация портов**, **ответы на разные типы пакетов (SYN/ACK/RST)**                  | `sudo hping3 -S -p 80 google.com`                                              |
| **HTTP/HTTPS**           | `curl`             | **HTTP-коды** (200/403/500), **время подключения**, **SSL-сертификаты**                 | `curl -v -o /dev/null https://google.com`                                      |
| **Мониторинг**           | `Prometheus`+`Grafana` | **Тренды загрузки сети**, **аномальные скачки**, **ошибки интерфейса**               | Настройка алертов на `ifHCOutOctets` (трафик)                                  |
|                         | `Zabbix`           | **Доступность сервисов**, **нагрузка на порты**, **история проблем**                     | Триггеры на `net.tcp.port[80] = 0`                                             |
| **Утилиты**              | `netcat` (`nc`)    | **Таймауты**, **отказ в подключении**, **неожиданные ответы**                           | `nc -zv 192.168.1.1 22`                                                        |
|                         | `ethtool`          | **Duplex/Speed**, **CRC-ошибки**, **переполнение буфера**                               | `ethtool -S eth0 \| grep errors`                                               |
|                         | `ip`/`ifconfig`    | **Неожиданные IP/MAC**, **отсутствие интерфейса (DOWN)**                                | `ip -s link show eth0`                                                         |
| **Безопасность**         | `nmap`             | **Неожиданно открытые порты**, **версии ПО**, **уязвимые сервисы**                      | `nmap -sV -T4 192.168.1.1`                                                     |
|                         | `fail2ban`         | **Блокировки IP**, **подозрительные попытки входа**                                     | `sudo fail2ban-client status sshd`                                             |

---

### **Как использовать таблицу?**
1. **Проблема с задержкой** → `ping` → `mtr` → `tcpdump` (ищем потери/задержки).  
2. **Сайт не грузится** → `curl -v` → `dig` → `ss -tulnp` (проверяем DNS и порты).  
3. **Подозрительный трафик** → `iftop` → `ngrep` → `Wireshark` (анализируем содержимое).  
4. **Нет подключения к порту** → `nc -zv` → `iptables -L` → `lsof -i :PORT`.  

Для **мониторинга** (Prometheus/Grafana) ключевые метрики:  
- `node_network_receive_bytes_total` (трафик).  
- `node_network_up` (статус интерфейса).  
- `probe_http_status_code` (доступность HTTP).  

Для **безопасности**:  
- `nmap` для аудита открытых портов.  
- `fail2ban` для блокировки bruteforce.  


---
### **Что происходит при вводе URL в адресную строку: полный разбор**

Когда вы вводите `https://example.com` в браузер, запускается цепочка из десятков процессов. Разберём их **пошагово**, с техническими деталями и примерами команд Linux для диагностики.  

---

## **1. Разбор URL и проверка кеша**
### **Что происходит:**
1. Браузер разбирает URL:
   - **Протокол**: `https://` (если не указан, подставляется `http://`).
   - **Домен**: `example.com`.
   - **Ресурс**: `/` (если не указан).
2. Проверяет **кеш**:
   - DNS-кеш (чтобы не резолвить домен повторно).
   - HTTP-кеш (если страница уже загружалась).

### **Как проверить в Linux:**
```bash
# DNS-кеш (если используется systemd-resolved)
systemd-resolve --statistics
# или (для браузеров)
chrome://net-internals/#dns
```

---

## **2. DNS-запрос (преобразование домена в IP)**
### **Что происходит:**
1. Браузер проверяет:
   - Локальный DNS-кеш (в ОС и браузере).
   - Файл `/etc/hosts` (если домен прописан там).
2. Если IP не найден, идёт **рекурсивный DNS-запрос**:
   - Запрос к DNS-серверу из `/etc/resolv.conf` (например, `8.8.8.8`).
   - Если DNS-сервер не знает IP, он запрашивает корневые серверы (`.`), затем TLD-серверы (`.com`), и наконец — авторитативный сервер для `example.com`.

### **Как смоделировать в Linux:**
```bash
dig +trace example.com          # Полный путь DNS-запроса
nslookup example.com            # Простой запрос
systemd-resolve example.com     # Через systemd
```

---

## **3. Установка TCP-соединения (3-way handshake)**
### **Что происходит:**
1. Браузер открывает **TCP-сокет** к IP-адресу `example.com` на порт `443` (для HTTPS).
2. Происходит **тройное рукопожатие**:
   - Клиент → Сервер: `SYN` (запрос на соединение).
   - Сервер → Клиент: `SYN-ACK` (подтверждение).
   - Клиент → Сервер: `ACK` (финальное подтверждение).

### **Как перехватить в Linux:**
```bash
sudo tcpdump -i eth0 'host example.com and port 443'
# Вывод будет содержать:
# 1. [SYN]
# 2. [SYN, ACK]
# 3. [ACK]
```

---

## **4. TLS-рукопожатие (для HTTPS)**
### **Что происходит:**
1. Клиент отправляет **ClientHello** (поддерживаемые шифры, TLS-версии).
2. Сервер отвечает **ServerHello** (выбранный шифр, сертификат).
3. Клиент проверяет сертификат (например, через CA).
4. Генерируется **общий ключ** (по алгоритму Диффи-Хеллмана).
5. Начинается **шифрованное соединение**.

### **Как проверить сертификат:**
```bash
openssl s_client -connect example.com:443 -servername example.com | openssl x509 -noout -text
# Проверка срока действия:
openssl x509 -enddate -noin -in <(openssl s_client -connect example.com:443 2>/dev/null)
```

---

## **5. HTTP/2 или HTTP/1.1 запрос**
### **Что происходит:**
1. Браузер отправляет **HTTP-запрос**:
   ```http
   GET / HTTP/2
   Host: example.com
   User-Agent: Mozilla/5.0
   Accept: text/html
   ```
2. Сервер отвечает:
   - **HTTP-статусом** (например, `200 OK`).
   - **Заголовками** (`Content-Type`, `Cache-Control`).
   - **Телом ответа** (HTML, CSS, JS).

### **Как отправить запрос вручную:**
```bash
curl -v https://example.com
# Или с HTTP/2:
curl --http2 -v https://example.com
```

---

## **6. Загрузка ресурсов (HTML, CSS, JS, изображения)**
### **Что происходит:**
1. Браузер парсит HTML, находит `<link>`, `<script>`, `<img>`.
2. Для каждого ресурса повторяются шаги **2–5** (DNS, TCP, TLS, HTTP).
3. Ресурсы кешируются (если есть `Cache-Control`).

### **Как проверить загрузку:**
```bash
# Используем `curl` для каждого ресурса:
curl -o /dev/null -s -w "%{time_total}s\n" https://example.com/style.css
```

---

## **7. Рендеринг страницы**
### **Что происходит:**
1. Браузер строит **DOM** (объектную модель документа).
2. Применяет **CSSOM** (стили).
3. Запускает **JavaScript**.
4. Отображает пиксели на экране (**Layout → Paint → Composite**).

### **Как профилировать:**
- В Chrome: `F12 → Performance`.
- В Linux (если браузер на удалённом сервере):
  ```bash
  # Запуск headless-браузера:
  google-chrome --headless --dump-dom https://example.com
  ```

---

## **8. Дополнительные процессы**
### **Кеширование:**
- **DNS-кеш**: `sudo systemd-resolve --flush-caches`.
- **HTTP-кеш**: Ctrl+F5 в браузере (принудительное обновление).

### **Оптимизации:**
- **TCP Fast Open (TFO)**: Ускоряет повторные соединения.
  ```bash
  sysctl net.ipv4.tcp_fastopen
  ```
- **HTTP/2 Server Push**: Сервер заранее отправляет ресурсы.

---

## **Итоговая схема**
```
1. Ввод URL → Разбор → Кеш
2. DNS → /etc/hosts → Рекурсивный запрос
3. TCP (3-way handshake)
4. TLS (шифрование)
5. HTTP-запрос (GET /)
6. Загрузка ресурсов (CSS, JS)
7. Рендеринг (DOM → CSSOM → JS → Paint)
```

---

## **Как диагностировать проблемы?**

| **Этап**       | **Инструменты Linux**                     | **Частые ошибки**               |
|----------------|-------------------------------------------|---------------------------------|
| DNS            | `dig`, `nslookup`, `systemd-resolve`      | `NXDOMAIN`, таймауты            |
| TCP            | `tcpdump`, `ss`, `netstat`                | `SYN` без ответа (фаервол)      |
| TLS            | `openssl s_client`, `curl -v`             | Просроченный сертификат         |
| HTTP           | `curl`, `wget`, `httpie`                  | `404 Not Found`, `502 Bad Gateway` |
| Загрузка       | `chromium --headless`, `lighthouse`       | Медленные ресурсы               |

---

## **Пример полной диагностики**
**Проблема:** Сайт не открывается.  

1. **Проверяем DNS:**
   ```bash
   dig example.com +short
   ```
   - Если нет ответа → смотрим `/etc/resolv.conf`.  

2. **Проверяем TCP-порт 443:**
   ```bash
   nc -zv example.com 443
   ```
   - Если `Connection refused` → сервер не слушает порт.  

3. **Проверяем TLS:**
   ```bash
   openssl s_client -connect example.com:443
   ```
   - Ошибка `SSL23_GET_SERVER_HELLO` → несовместимость TLS.  

4. **Проверяем HTTP:**
   ```bash
   curl -v https://example.com
   ```
   - Если `HTTP/2 200` → проблема в браузере.  

---

### **Концепции iptables и методы troubleshooting**

---

## **1. Основы iptables**
**iptables** — это фаервол и система фильтрации пакетов в Linux, работающая на уровне ядра. Она управляет сетевым трафиком через наборы правил (таблицы, цепочки и правила).

### **1.1. Таблицы iptables**
В iptables есть 5 основных таблиц (по умолчанию используются первые 3):

| **Таблица**       | **Назначение**                                                                 |
|-------------------|-------------------------------------------------------------------------------|
| **filter**        | Основная таблица для фильтрации пакетов (разрешить/запретить трафик).         |
| **nat**           | Изменение IP/портов (NAT, маскарадинг, проброс портов).                       |
| **mangle**        | Модификация заголовков пакетов (TTL, QoS, метки).                             |
| **raw**           | Отключение отслеживания соединений (connection tracking).                     |
| **security**      | Используется для SELinux (редко применяется).                                 |

---

### **1.2. Цепочки (Chains)**
Каждая таблица содержит цепочки, через которые проходят пакеты:

| **Цепочка**       | **Когда срабатывает**                                                                 |
|-------------------|-------------------------------------------------------------------------------------|
| **INPUT**         | Пакеты, **адресованные текущей машине** (например, входящий SSH).                   |
| **OUTPUT**        | Пакеты, **отправляемые с текущей машины** (например, запросы наружу).               |
| **FORWARD**       | Пакеты, **проходящие через машину** (если она работает как роутер).                 |
| **PREROUTING**    | Пакеты **до маршрутизации** (используется в `nat`, `mangle`, `raw`).                |
| **POSTROUTING**   | Пакеты **после маршрутизации** (используется в `nat`, `mangle`).                    |

---

### **1.3. Структура правил**
Каждое правило состоит из:
- **Условия** (например, `-p tcp --dport 80`).
- **Действия** (`ACCEPT`, `DROP`, `REJECT`, `LOG`, `SNAT`, `DNAT`).

Пример:
```bash
iptables -A INPUT -p tcp --dport 22 -j ACCEPT  # Разрешить SSH
```

---

## **2. Основные команды iptables**
### **Просмотр правил**
```bash
iptables -L -v -n            # Показать все правила (фильтр)
iptables -t nat -L -v -n     # Показать правила NAT
iptables -S                  # Показать правила в формате команд
```

### **Добавление/удаление правил**
```bash
iptables -A INPUT -p tcp --dport 80 -j ACCEPT   # Добавить правило
iptables -D INPUT 1                             # Удалить правило №1 из INPUT
iptables -F                                     # Очистить все правила
```

### **Сохранение правил**
```bash
iptables-save > /etc/iptables.rules            # Сохранить
iptables-restore < /etc/iptables.rules         # Восстановить
```

---

## **3. Примеры использования**
### **3.1. Блокировка трафика**
```bash
iptables -A INPUT -s 192.168.1.100 -j DROP      # Запретить IP
iptables -A INPUT -p tcp --dport 22 -j DROP     # Запретить SSH
```

### **3.2. Проброс портов (NAT)**
```bash
iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 10.0.0.2:80
iptables -t nat -A POSTROUTING -j MASQUERADE    # Маскарадинг для интернета
```

### **3.3. Логирование пакетов**
```bash
iptables -A INPUT -p tcp --dport 22 -j LOG --log-prefix "SSH Attempt: "
```
Логи можно найти в `/var/log/syslog` или `journalctl -k`.

---

## **4. Методы troubleshooting iptables**
### **4.1. Проверка текущих правил**
```bash
iptables -L -v -n --line-numbers
```
- **Ключи:**
  - `-L` — список правил.
  - `-v` — подробный вывод.
  - `-n` — не резолвить IP в имена.
  - `--line-numbers` — показать номера строк (удобно для удаления правил).

---

### **4.2. Поиск блокирующих правил**
Если трафик не проходит:
1. Проверьте **порядок правил** (iptables применяет первое совпадение!).
2. Ищите `DROP` или `REJECT`:
   ```bash
   iptables -L | grep -i "DROP\|REJECT"
   ```

---

### **4.3. Проверка логов iptables**
Если включено логирование (`-j LOG`):
```bash
dmesg | grep "SSH Attempt"      # Пример для правила с --log-prefix
journalctl -k -f | grep iptables
```

---

### **4.4. Тестирование правил**
#### **Сброс счетчиков**
```bash
iptables -Z                     # Обнулить счётчики пакетов/байт
```
#### **Проверка, сколько пакетов попало под правило**
```bash
iptables -L -v                  # Смотрим столбцы "pkts" и "bytes"
```

---

### **4.5. Временное отключение фаервола**
```bash
iptables -P INPUT ACCEPT        # Разрешить весь входящий трафик
iptables -P OUTPUT ACCEPT       # Разрешить весь исходящий трафик
iptables -P FORWARD ACCEPT      # Разрешить форвардинг
iptables -F                     # Очистить все правила
```

---

## **5. Частые проблемы и решения**
### **5.1. Правило добавлено, но не работает**
- **Причина:** Правило добавлено в конец цепочки, а выше есть `DROP`.
- **Решение:** Вставьте правило в начало:
  ```bash
  iptables -I INPUT 1 -p tcp --dport 80 -j ACCEPT
  ```

### **5.2. NAT не работает**
- **Проверьте:**
  - Включён ли форвардинг?
    ```bash
    sysctl net.ipv4.ip_forward  # Должно быть =1
    ```
  - Есть ли правило `MASQUERADE` или `SNAT`?
    ```bash
    iptables -t nat -L
    ```

### **5.3. SSH заблокирован**
- **Решение:** Разрешите SSH и добавьте правило в начало:
  ```bash
  iptables -I INPUT 1 -p tcp --dport 22 -j ACCEPT
  ```

---

## **6. Альтернативы iptables**
- **nftables** — новая замена iptables (встроена в ядро Linux).
- **firewalld** — надстройка для iptables/nftables (используется в RHEL/CentOS).
- **UFW** — упрощённый фаервол для Ubuntu (`ufw allow 22`).

---

## **Вывод**
1. **iptables** управляет трафиком через **таблицы** (`filter`, `nat`, `mangle`), **цепочки** (`INPUT`, `OUTPUT`, `FORWARD`) и **правила**.
2. **Порядок правил важен** — первое совпадение определяет судьбу пакета.
3. **Troubleshooting:**
   - Смотрите логи (`dmesg`, `journalctl`).
   - Проверяйте счётчики (`iptables -L -v`).
   - Тестируйте с отключённым фаерволом.

