# Основные виды методов тестирования безопасности (Security Testing), выстроенные по принципу жизненного цикла приложения (от кода к продакшену):

### 1. SCA (Software Composition Analysis) / Анализ зависимостей

*   **Что это?** Анализ сторонних библиотек и компонентов (зависимостей), которые вы используете в своем проекте (например, npm-пакеты, библиотеки из Maven, PyPI).
*   **Что ищет?** Известные уязвимости (CVE - Common Vulnerabilities and Exposures) в используемых версиях этих библиотек.
*   **Когда проводится?** На этапе разработки и сборки (в CI).
*   **Инструменты:** **OWASP Dependency-Check**, **Snyk**, **GitHub Dependabot**, **GitLab Dependency Scanning**, **Sonatype Nexus Lifecycle**, **WhiteSource Bolt**.
*   **Аналогия:** Это как проверять, нет ли отзывов (уязвимостей) на запчасти (библиотеки), которые вы используете для сборки своего автомобиля (приложения).

### 2. SAST (Static Application Security Testing)

* **Что это?** Анализ исходного кода, байт-кода или бинарного кода на наличие уязвимостей *до* запуска приложения (на этапе "статики").
*  **Когда проводится?** "SAST — это первый рубеж обороны в DevSecOps. Мы интегрируем его в этап `build` пайплайна, чтобы разработчик получил быструю обратную связь прямо в Merge Request еще до того, как код попадет в основную ветку. Это сдвигает безопасность влево (Shift Left)."
* **Ключевые инструменты:**
   **SonarQube:** Лидер рынка. Анализирует не только безопасность (уязвимости OWASP Top 10), но и "чистоту кода": покрытие тестами, технический долг, баги, code smells.
   **Svace:** Статический анализатор, который часто используется для больших C/C++/Java проектов. Хорош для поиска глубоких багов и уязвимостей.


### 3. IAC Security Scanning / Анализ безопасности инфраструктуры как кода

*   **Что это?** Анализ конфигурационных файлов, которые описывают вашу инфраструктуру (Terraform, Ansible, Kubernetes manifests, CloudFormation).
*   **Что ищет?** Неправильные конфигурации, которые могут привести к уязвимости в развернутой инфраструктуре. Например: открытый SSH-порт в security group, S3-бакет с публичным доступом, поды в Kubernetes, работающие с правами root.
*   **Когда проводится?** В пайплайне CI, когда вы проверяете и мержите свой Infrastructure as Code (IaC).
*   **Инструменты:** **Terrascan**, **Checkov**, **tfsec**, **kube-score**, **kube-bench**, **Datree**.
*   **Аналогия:** Это как проверять чертежи (IaC-файлы) вашего дома (инфраструктуры) на предмет ошибок, из-за которых в дом могут легко проникнуть грабители (например, забыли поставить замок на дверь).

### 4. Secret Scanning / Сканирование на наличие секретов

*   **Что это?** Специализированный вид сканирования, который ищет случайно закоммиченные секреты (ключи API, пароли, токены) в кодовой базе и истории Git.
*   **Когда проводится?** Как пре-коммит хук (на машине разработчика) и/или как этап в CI-пайплайне (например, при пуше в репозиторий).
*   **Инструменты:** **GitLeaks**, **TruffleHog**, **git-secrets**. Также встроено в **GitHub Advanced Security**, **GitLab**.
*   **Аналогия:** Это как проверять, не оставили ли вы ключи от дома (секреты) на видном месте у всех на виду (в коде).


### 5. Container Scanning / Сканирование контейнеров

*   **Что это?** Анализ собранных Docker-образов на наличие уязвимостей в базовом образе (OS packages - apt, yum, apk) и установленных в него приложениях.
*   **Что ищет?** Известные уязвимости (CVE) в операционной системе и пакетах внутри контейнера.
*   **Когда проводится?** На этапе сборки образа (после команды `docker build`) в CI-пайплайне.
*   **Инструменты:** **Trivy** (очень популярен и прост), **Grype**, **Snyk Container**, **Clair**, **Anchore Engine**.
*   **Аналогия:** Это как проверять фундамент и стены вашего дома (базовый образ ОС) на наличие трещин и слабых мест (уязвимостей), прежде чем начать в нем жить (запускать контейнер).

### 6. DAST (Dynamic Application Security Testing)

* **Что это?** Анализ работающего приложения (чаще всего через HTTP-запросы) на наличие уязвимостей *после* его развертывания (на этапе "динамики"). Имитирует действия злоумышленника.
*   **Когда проводится?**  "DAST — это второй рубеж. Он находит проблемы, которые не видны в коде, например, misconfiguration сервера, проблемы аутентификации и сессий. Мы запускаем DAST-сканирование на стенде (staging), куда разворачивается наше приложение после успешного прохождения всех этапов пайплайна."
* **Ключевые инструменты:**
*   **OWASP ZAP (Open Source):** Самый популярный бесплатный инструмент. Идеально для CI/CD.
*   **Burp Suite Professional:** Промышленный стандарт для пентестеров, имеет мощный движок автоматического сканирования.
*   **Acunetix, Qualys:** Коммерческие Enterprise-решения.

### 7. RASP (Runtime Application Self-Protection)

*   **Что это?** Технология защиты, встроенная непосредственно в запущенное приложение или его среду выполнения (runtime).
*   **Как работает?** RASP-агент постоянно анализирует поведение приложения и входящий трафик. При обнаружении атаки (например, попытка SQL-инъекции) он может заблокировать ее в реальном времени, не полагаясь на внешние файерволы.
*   **Когда работает?** Непрерывно во время выполнения приложения в продакшене или на стейджинге.
*   **Инструменты:** **Fortify Real-Time Protect**, **Imperva RASP**, **Contrast Security**.
*   **Аналогия:** Это как иммунная система у живого организма (приложения). Она постоянно работает изнутри, идентифицируя и нейтрализуя угрозы.

### 8. Fuzzing (Фаззинг-тестирование)

*   **Что это?** Метод тестирования, при котором в программу подаются невалидные, неожиданные или случайные данные (фаззинг-данные) с целью спровоцировать сбой, утечку памяти или найти уязвимость.
*   **Когда проводится?** Чаще используется на этапе тестирования критичных к безопасности компонентов (парсеры, декодеры).
*   **Инструменты:** **AFL**, **libFuzzer**, **Jazzer** (для Java).

### Как это все объединяется в пайплайне?

Хороший DevOps-инженер должен видеть, как эти проверки встраиваются в единый процесс:

1.  **Pre-commit / Pre-merge:** Secret Scanning, форматирование кода.
2.  **CI / Build:**
    *   **Сборка:** SAST (анализ *вашего* кода), Unit-тесты (JUnit).
    *   **Зависимости:** SCA (анализ *чужого* кода - библиотек).
    *   **Контейнеризация:** Container Scanning (анализ ОС в образе).
    *   **Инфраструктура:** IAC Scanning (анализ конфигов Terraform/K8s).
3.  **После деплоя на Staging:** DAST (тестирование *работающего* приложения), Нагрузочное тестирование.
4.  **В Продакшене:** RASP (защита в реальном времени), мониторинг и аудит.

**Идеальный подход — это не выбор одного инструмента, а **комбинация нескольких методов (Defense in Depth)**, так как каждый из них ищет проблемы на своем уровне и перекрывает "слепые зоны" других.

## 2. Встраивание SAST/DAST в CI/CD пайплайн (на примере GitLab CI/CD)

Это самый важный практический вопрос. Приготовьтесь рисовать блок-схему или описывать stages.

**Пример пайплайна:**
{% raw %}
```yaml
stages:
  - build
  - test
  - deploy:staging
  - test:dast
  - deploy:production

variables:
  SONAR_SCANNER_VERSION: "5.0.1.3006"
  SONAR_HOST_URL: "https://sonar.your-company.com"
  # SONAR_TOKEN задается в переменных GitLab CI/CD (Settings -> CI/CD -> Variables)

build:
  stage: build
  image: maven:3.8.6-openjdk-11
  script:
    - mvn compile

sast-sonarqube:
  stage: test
  image: sonarsource/sonar-scanner-cli:latest
  needs: [build] # Зависит от стадии build
  script:
    - sonar-scanner
      -Dsonar.projectKey=my-project
      -Dsonar.java.binaries=target/classes
      -Dsonar.login=$SONAR_TOKEN
  allow_failure: false # Если качество кода не пройдет - пайплайн упадет!

unit-tests:
  stage: test
  image: maven:3.8.6-openjdk-11
  script:
    - mvn test # JUnit тесты запускаются здесь, отчет о покрытии будет отправлен в SonarQube

deploy-to-staging:
  stage: deploy:staging
  image: kubectl:latest
  script:
    - kubectl apply -f k8s/manifest-staging.yaml
  only:
    - main

dast-scan:
  stage: test:dast
  image: owasp/zap2docker-stable:latest
  needs: [deploy-to-staging] # Ждем, когда приложение встанет на staging
  script:
    - zap-baseline.py -t https://staging.your-company.com -r zap-report.html
  artifacts:
    paths:
      - zap-report.html
  allow_failure: true # Часто DAST сканирование допускает warnings, но не прерывает пайплайн. Результат надо проверять.

deploy-to-production:
  stage: deploy:production
  image: kubectl:latest
  script:
    - kubectl apply -f k8s/manifest-production.yaml
  only:
    - main
  when: manual # Ручное подтверждение деплоя в prod после проверки всех отчетов (в т.ч. DAST)
```
{% endraw %}

**Важные нюансы для обсуждения:**
*   **`allow_failure: true/false`:** Где мы останавливаем пайплайн, а где только собираем отчет для ручной проверки?
*   **Quality Gates в SonarQube:** Это пороги качества ("не более 5 багов", "покрытие тестами > 80%"). Если порог не пройден — пайплайн падает.
*   **Производительность:** SAST/DAST могут работать долго. Можно использовать кэширование, запускать их параллельно с другими тестами или использовать `only: [merge_requests]` для SAST.

### 4. Хранение секретов (Secrets Management)

**Проблема:** Никогда нельзя хранить пароли, токены, ключи API в коде или в конфигурационных файлах репозитория.

**Решения:**

1.  **Использование возможностей CI/CD системы:**
    *   **GitLab:** Settings -> CI/CD -> Variables (можно отметить `Masked` и `Protected`).
    *   **GitHub Actions:** Secrets в настройках репозитория.
    *   *Как использовать:* В пайплайне обращаемся как к переменной окружения `$SONAR_TOKEN` или `$PROD_DB_PASSWORD`.

2.  **Специализированные системы (Золотой стандарт):**
    *   **HashiCorp Vault:** Самое популярное и мощное решение.
    *   **AWS Secrets Manager / Azure Key Vault / GCP Secret Manager:** Нативные решения облачных провайдеров.
    *   **Как использовать:** В пайплайне добавляем шаг, который перед деплоем обращается к Vault (через его CLI или API), получает секрет и использует его (например, подставляет в k8s манифест или передает приложению через переменную окружения).

**Пример с Vault в CI/CD:**
{% raw %}
```yaml
deploy-to-production:
  stage: deploy:production
  image:
    name: bitnami/kubectl:latest
    entrypoint: [""]
  script:
    # 1. Получаем секрет из Vault (логинимся через предварительно настроенный механизм, например, JWT)
    - export DB_PASSWORD=$(vault kv get -field=password secret/prod/db)
    # 2. Подставляем его в манифест (например, через envsubst)
    - envsubst < k8s/manifest-production.tpl.yaml > k8s/manifest-production.yaml
    # 3. Деплоим
    - kubectl apply -f k8s/manifest-production.yaml
```
{% endraw %}
---

### 5. JUnit и JProfiler

*   **JUnit:** Это фреймворк для модульного тестирования (Unit Testing). Его роль в пайплайне — обеспечить **покрытие кода тестами (code coverage)**. Сборка отчетов (например, через `maven-surefire-plugin`) и их отправка в SonarQube для анализа.
    *   *На собеседовании:* "Мы запускаем `mvn test`, чтобы выполнить модульные тесты. SonarQube забирает сгенерированный отчет `jacoco.xml` (или другой) для расчета процента покрытия и отображения его в Quality Gate."

*   **JProfiler:** Это профайлер для анализа производительности Java-приложений. Его использование в CI/CD **не является стандартной практикой**, так как требует ручного анализа и глубокого погружения.
    *   *На собеседовании:* "JProfiler — это мощный инструмент, но обычно он используется разработчиками и инженерами по производительности *ад-hoc* для диагностики проблем на тестовых стендах, а не в автоматическом пайплайне. В CI/CD для проверки производительности чаще используют нагрузочное тестирование (например, с помощью Gatling или JMeter)."

### Вопросы, которые могут задать на собеседовании:

1.  **В чем главное отличие SAST от DAST?** (Статика vs. Динамика, этап запуска, типы найденных уязвимостей).
2.  **Что такое Shift Left?** (Принцип "сдвига" безопасности и тестирования на ранние этапы разработки).
3.  **Ваш пайплайн упал на этапе SAST из-за низкого покрытия кода тестами. Что вы сделаете?** (Обсудить с командой, написать тесты, возможно, временно настроить менее строгий Quality Gate для нового проекта).
4.  **Как вы организуете хранение секретов для доступа к самому Vault из пайплайна?** (Креденциалы для доступа к Vault хранятся в переменных CI/CD, которые настраиваются владельцем репозитория/админом).
5.  **DAST-сканирование работает очень долго. Как можно оптимизировать пайплайн?** (Запускать его не на каждый коммит в `main`, а только по тегам/вручную; использовать инкрементальный анализ в SAST; запускать этапы параллельно).

