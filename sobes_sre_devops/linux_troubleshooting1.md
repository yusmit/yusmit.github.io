## **Типовые вопросы на собеседовании**
1. **Как найти процесс, который исчерпывает память?**  
   → `top` → `M`, `smem -s swap`, `pmap -x <PID>`.  

2. **Как определить, почему не работает сеть между серверами?**  
   → `ping` → `traceroute` → `tcpdump` → проверка фаервола (`iptables -L`).  

3. **Как диагностировать высокий `iowait`?**  
   → `iostat -x 1`, `iotop`, `strace -e trace=file <PID>`.  

4. **Что делать, если `df` показывает 100% использование, но `du` — нет?**  
   → Удалить "закрытые" файлы (например, лог-файлы, удалённые процессом: `lsof | grep deleted`).  


## **1. Процессы и нагрузка на CPU**
### **Проблема:** Сервер "тормозит", нагрузка CPU под 100%.
#### **Инструменты и действия:**
1. **Быстрая диагностика:**  
   - `top` → нажать `1` (показать все ядра), `P` (сортировка по CPU).  
   - `htop` — более удобная альтернатива (цветовая подсветка, дерево процессов).  
   - `atop` — историческая статистика (покажет пики нагрузки).  

2. **Анализ узкого места:**  
   - **User vs System CPU:**  
     - Высокий `us` (user) — проблема в приложении.  
     - Высокий `sy` (system) — проблема в ядре (например, много системных вызовов).  
   - **`perf` для профилирования:**  
     ```bash
     perf top -g                  # Режим реального времени
     perf record -g -p <PID>      # Запись данных процесса
     perf report                  # Анализ (ищем "горячие" функции)
     ```  
     **Пример:** Если `sy` высокий, ищем частые вызовы `read()`/`write()` — возможно, проблема с диском.  

3. **Глубокий анализ системных вызовов:**  
   - `strace -p <PID> -c` — суммарная статистика вызовов.  
   - `strace -p <PID> -e trace=file` — только файловые операции.  
   - **Кейс:** Процесс "висит" — смотрим, на каком вызове:  
     ```bash
     strace -p <PID>              # Если завис на `poll()` — ждёт I/O.
     ```

---

## **2. Память (OOM, утечки, swap)**
### **Проблема:** Сервер использует swap, приложения падают с `OOM Killer`.
#### **Инструменты:**
1. **Обзор памяти:**  
   - `free -h` — общее использование (`available` важнее `free`!).  
   - `vmstat 1` — статистика памяти, swap, I/O.  

2. **Поиск "пожирателей" памяти:**  
   - `top` → `M` (сортировка по памяти).  
   - `smem -s swap` — процессы, использующие swap.  
   - `pmap -x <PID>` — детальная карта памяти процесса.  

3. **OOM Killer:**  
   - Логи: `dmesg | grep -i oom`.  
   - Как предотвратить:  
     - Настроить `vm.overcommit_memory`, `vm.swappiness`.  
     - Ограничить память для контейнеров (Docker: `-m`).  

4. **Утечки памяти:**  
   - `valgrind --leak-check=yes ./app` — для разработки.  
   - `bpftrace` для отслеживания аллокаций:  
     ```bash
     bpftrace -e 'tracepoint:kmem:kmalloc { @[comm] = count(); }'
     ```

---

## **3. Дисковые проблемы (I/O, inodes, fsck)**
### **Проблема:** Высокий `iowait`, медленные запросы к диску.
#### **Инструменты:**
1. **Мониторинг:**  
   - `iostat -x 1` — %util > 90% означает перегрузку диска.  
   - `iotop` — процессы, активно работающие с диском.  

2. **Анализ файловых дескрипторов:**  
   - `lsof -p <PID>` — какие файлы открыты процессом.  
   - `lsof /var` — кто использует раздел `/var`.  

3. **Проблемы с inodes:**  
   - `df -i` — проверка исчерпания inodes.  
   - Поиск миллионов мелких файлов:  
     ```bash
     find / -xdev -type f | awk '{print $NF}' | cut -d/ -f2 | sort | uniq -c | sort -n
     ```

4. **Файловая система повреждена:**  
   - `fsck /dev/sdX` — проверка и восстановление (только с unmounted FS!).  

---

## **4. Сетевые проблемы (latency, packet loss, DNS)**
### **Проблема:** Соединение медленное или обрывается.
#### **Инструменты:**
1. **Базовые проверки:**  
   - `ping <host>` — проверка доступности и RTT.  
   - `mtr <host>` — аналог `traceroute` с статистикой потерь.  

2. **Анализ локальных сокетов:**  
   - `ss -tulnp` — кто слушает порты (`netstat` устарел).  
   - `ss -s` — общая статистика (например, `retransmit`).  

3. **Перехват трафика:**  
   - `tcpdump -i eth0 -w dump.pcap 'port 80'` — сохранить в файл.  
   - `tshark -r dump.pcap -Y "http.request"` — фильтр HTTP в Wireshark.  

4. **Глубокий анализ:**  
   - **Проблемы с MTU:**  
     ```bash
     ping -M do -s 1472 <host>   # Проверка MTU (1472 + 28 = 1500)
     ```  
   - **Статистика сетевого стека:**  
     ```bash
     netstat -s                  # Вывод статистики TCP/UDP
     ethtool -S eth0             # Ошибки на интерфейсе
     ```

---

## **5. Проблемы с ядром (kernel panic, soft lockup)**
### **Проблема:** Сервер "зависает", сообщения в `dmesg`.
#### **Инструменты:**
1. **Анализ логов:**  
   - `dmesg -T` — читаем время и сообщения (например, `OOM`, `soft lockup`).  
   - `journalctl -k --since "1 hour ago"` — логи ядра.  

2. **Отладка `soft lockup`:**  
   - Увеличить таймаут: `echo 30 > /proc/sys/kernel/watchdog_thresh`.  
   - Поиск "зависших" потоков ядра: `perf record -g -a sleep 10`.  

3. **Kernel panic:**  
   - Анализ дампа: `crash` + `vmcore`.  
   - Проверить аппаратные ошибки: `smartctl -a /dev/sdX`.  

---

## **6. Полезные команды для быстрой диагностики**
```bash
# Общий статус системы
dmesg -T | tail -20            # Последние ошибки ядра
uptime                          # Load average
vmstat 1                        # CPU, memory, I/O
iostat -x 1                     # Дисковая нагрузка
sar -n DEV 1                    # Сетевой трафик

# Поиск проблемных процессов
ps aux --sort=-%cpu | head      # Топ по CPU
ps aux --sort=-%mem | head      # Топ по памяти
lsof -i :80                     # Кто использует порт 80
```

---

## **Практика**
1. **Симулируй проблему:**  
   - `stress-ng --cpu 4 --io 2 --vm 1 --vm-bytes 1G` — нагрузка на CPU, I/O, память.  
   - `dd if=/dev/zero of=/tmp/test bs=1M count=10K` — заполнение диска.  

2. **Найди и исправь:**  
   - Запусти сервер Apache, "поломай" его (например, `iptables -A INPUT -p tcp --dport 80 -j DROP`), затем восстанови.  



## **Кейс 1: Сервер "лагает", нагрузка CPU 90%+**
### **Симптомы:**  
- Команда `top` показывает `%us` (user CPU) под 90%, но непонятно, какой процесс виноват.  
- Приложение медленно отвечает.  

### **Диагностика:**  
1. **Определяем процесс-нарушитель:**  
   ```bash
   top -c -o %CPU   # Сортировка по CPU (показывает команду процесса)
   ```
   - Если процесс — `java/python/php`, возможно, это утечка или бесконечный цикл.  

2. **Анализируем системные вызовы:**  
   ```bash
   strace -p <PID> -c   # Смотрим, какие вызовы доминируют
   ```
   - Если много `read()`/`write()` — проблема с диском.  
   - Если `poll()`/`epoll_wait()` — процесс ждёт I/O.  

3. **Профилируем CPU:**  
   ```bash
   perf top -g -p <PID>   # Ищем "горячие" функции в коде
   ```
   - Пример: Увидели, что 50% времени уходит в `libcrypto` — возможно, криптооперации.  

4. **Проверяем логи приложения:**  
   ```bash
   journalctl -u <service> --since "1 hour ago" | grep -i error
   ```

### **Решение:**  
- Оптимизировать код (если своё приложение).  
- Для стороннего ПО — обновить версию или настроить лимиты (например, `systemd` параметры `CPUQuota`).  

---

## **Кейс 2: Диск переполнен, но `du` не показывает файлы**
### **Симптомы:**  
- `df -h` показывает 100% использование `/var`, но `du -sh /var/*` — только 70%.  

### **Диагностика:**  
1. **Проверяем "удалённые" файлы:**  
   ```bash
   lsof +L1   # Показывает файлы, удалённые из FS, но открытые процессами
   ```
   - Пример: `nginx` пишет лог в `/var/log/access.log`, но файл "удалили" через `rm`.  

2. **Ищем большие файлы:**  
   ```bash
   find /var -type f -size +100M -exec ls -lh {} \;
   ```

3. **Проверяем inodes:**  
   ```bash
   df -i   # Если 100% — удаляем миллионы мелких файлов
   ```

### **Решение:**  
- Перезапустить процесс, держащий файл:  
  ```bash
  systemctl restart nginx
  ```
- Очистить кэш (если это `tmpfs`):  
  ```bash
  sync; echo 3 > /proc/sys/vm/drop_caches
  ```

---

## **Кейс 3: Сеть работает, но соединения обрываются**
### **Симптомы:**  
- `ping` проходит, но `curl https://example.com` падает с таймаутом.  
- В логах сервера нет запросов.  

### **Диагностика:**  
1. **Проверяем фаервол:**  
   ```bash
   iptables -L -n -v   # Ищем DROP/REJECT правил
   ```
   - Если есть правило `DROP --dport 443` — проблема в нём.  

2. **Анализируем маршрут:**  
   ```bash
   mtr -n example.com   # Проверяем потери пакетов
   ```

3. **Перехватываем трафик:**  
   ```bash
   tcpdump -i eth0 'port 443' -w tls.pcap   # Смотрим, уходят ли SYN-пакеты
   ```
   - Если SYN уходит, но нет SYN+ACK — проблема на удалённой стороне или по пути.  

4. **Проверяем MTU:**  
   ```bash
   ping -M do -s 1472 example.com   # Если не работает — уменьшаем MTU
   ```

### **Решение:**  
- Добавить правило в `iptables`:  
  ```bash
  iptables -A INPUT -p tcp --dport 443 -j ACCEPT
  ```
- Настроить `MTU` на интерфейсе:  
  ```bash
  ifconfig eth0 mtu 1400
  ```

---

## **Кейс 4: Процесс "висит" и не убивается**
### **Симптомы:**  
- `kill -9 <PID>` не работает.  
- Процесс в состоянии `D` (uninterruptible sleep).  

### **Диагностика:**  
1. **Смотрим статус процесса:**  
   ```bash
   ps aux | grep <PID>   # Состояние "D" — ждёт I/O (диск/сеть)
   ```

2. **Анализируем стек ядра:**  
   ```bash
   cat /proc/<PID>/stack   # Показывает, где "застрял" процесс
   ```

3. **Проверяем диск:**  
   ```bash
   dmesg | grep -i error   # Возможно, диск "отвалился"
   ```

### **Решение:**  
- Перезагрузить сервер (если процесс критический).  
- Если проблема с диском — проверить `smartctl` и заменить диск.  

---

## **Кейс 5: DNS-запросы работают медленно**
### **Симптомы:**  
- `dig example.com` занимает 5+ секунд.  
- `curl` тоже медленный, но `ping` быстрый.  

### **Диагностика:**  
1. **Проверяем DNS-серверы:**  
   ```bash
   cat /etc/resolv.conf   # Куда идут запросы?
   ```

2. **Тестируем разные резолверы:**  
   ```bash
   time dig @8.8.8.8 example.com   # Прямой запрос к Google DNS
   ```

3. **Ищем проблемы с IPv6:**  
   ```bash
   strace -e connect dig example.com   # Если видим `AF_INET6` и таймауты
   ```

### **Решение:**  
- Отключить IPv6 в `/etc/sysctl.conf`:  
  ```bash
  net.ipv6.conf.all.disable_ipv6 = 1
  ```
- Сменить DNS на `8.8.8.8` или `1.1.1.1`.  

---

## **Кейс 6: Ошибка "Too many open files"**
### **Симптомы:**  
- Приложение падает с ошибкой `Cant open file: Too many open files`.  

### **Диагностика:**  
1. **Проверяем лимиты:**  
   ```bash
   ulimit -n           # Лимит для текущей сессии
   cat /proc/<PID>/limits | grep "open files"   # Для процесса
   ```

2. **Ищем "протекающие" файловые дескрипторы:**  
   ```bash
   lsof -p <PID> | wc -l   # Сколько файлов открыто?
   ```

### **Решение:**  
- Увеличить лимиты в `/etc/security/limits.conf`:  
  ```bash
  * soft nofile 65535
  * hard nofile 65535
  ```
- Перезапустить приложение.  

---

## **Кейс 7: Не загружается система (Kernel Panic)**
### **Симптомы:**  
- После ребута видим `Kernel Panic - not syncing: VFS: Unable to mount root fs`.  

### **Диагностика:**  
1. **Проверяем параметры загрузки в GRUB:**  
   - В меню GRUB нажимаем `e`, ищем `root=` — правильный ли диск?  

2. **Восстанавливаем initramfs:**  
   ```bash
   mkinitrd -f /boot/initramfs-$(uname -r).img $(uname -r)
   ```

### **Решение:**  
- Загрузиться с live-CD, смонтировать `/` и восстановить `grub.cfg`.  

---

## **Итог: Чеклист для Troubleshooting**
1. **CPU:** `top → perf → strace`.  
2. **Память:** `free → pmap → valgrind`.  
3. **Диск:** `iostat → lsof → fsck`.  
4. **Сеть:** `ping → tcpdump → iptables`.  
5. **Процессы:** `ps → /proc/<PID>/stack → kill`.  
