#  **Процесс загрузки Linux** 

•  Стоит отметить, что загрузка ОС, это многоступенчатый процесс. В различных дистрибутивах Linux процесс загрузки может несколько изменяться, но общая схема примерно одинакова и состоит из следующих стадий:

1. В момент запуска процессор передаёт управление по определённому физическому адресу в ПЗУ. В этот момент начинается выполнение кода BIOS/UEFI. 
2. BIOS/UEFI определяет подключенные к системе устройства.
3. Выбор устройства (USB, Жесткий диск и т.д.) для загрузки и запуска ОС.
4. Начальный загрузчик считывает в память основной загрузчик (GRUB, LiLo, NTLDR) и передаёт управление ему.
5. После того, как выбранное ядро загружено в память и начинает исполняться, в первую очередь, оно должно извлечь самого себя из сжатой версии файла, перед тем как начать выполнять полезную работу. Как только извлечение произошло, оно загружает systemd и передает ему контроль.
6. systemd монтирует файловые системы, как определено в /etc/fstab, включая любые swap-файлы и разделы. К этому моменту, он может получить доступ к файлам конфигурации, расположенным в /etc, включая его собственным. Он использует собственный конфигурационный файл /etc/systemd/system/default.target, чтобы определить таргет (target), по которому нужно загрузить хост.
7. Запуск определенного набора стартовых скриптов и настройка рабочей среды.
8. Вход в систему. Система готова к работе.


# **Команда top**
Команда top выводит список работающих в системе процессов и информацию о них. По умолчанию утилита в реальном времени сортирует их по нагрузке на процессор. 
Некоторые колонки в выводе команды top и их значения:
PID — идентификатор процесса.
USER — имя пользователя, от имени которого выполняется процесс.
PR — приоритет планировщика, установленный для процесса.
NI — рекомендуемый приоритет процесса, который можно менять.
VIRT — всё, что находится в памяти, используется или зарезервировано для использования.
RES — всё, что находится в оперативной памяти и относится к процессу, указывается в килобайтах.
SHR — часть памяти из RES, которую занимают ресурсы, доступные для использования другим процессам.
S — состояние процесса: D — ожидает завершения операции, R — запущен, S — спит, T — остановлен, t — остановлен отладчиком, Z — зомби.
%CPU — процент использования ресурсов процессора.
%MEM — процент использования ресурсов оперативной памяти на основе колонки RES.
TIME — общее процессорное время, которое процесс использовал с момента запуска.
COMMAND — команда, с помощью которой был запущен процесс.

# **Ядро Linux**
1.  **Общие вопросы** (архитектура, особенности).
2.  **Управление процессами и планирование**.
3.  **Управление памятью**.
4.  **Файловые системы**.
5.  **Сеть и безопасность**.
6.  **Модули ядра и отладка**.
7.  **Практические задачи**.

---

## **1. Общие вопросы о ядре Linux**

### **Что такое ядро Linux?**
**Ответ:** Ядро — это фундаментальная часть операционной системы, которая управляет аппаратными ресурсами (CPU, память, устройства) и предоставляет интерфейс для пользовательских программ (системные вызовы).

### **Чем отличаются монолитное и микроядро?**
**Ответ:**
-   **Монолитное ядро** (Linux): Все компоненты (драйверы, планировщик, файловые системы) работают в одном адресном пространстве. Высокая производительность, но риск падения системы из-за ошибки в драйвере.
-   **Микроядро** (QNX, Minix): Только минимальные функции (потоки, IPC) в ядре. Драйверы и сервисы работают в пользовательском пространстве. Лучшая изоляция, но меньшая производительность.

### **Что такое пространство ядра и пользовательское пространство?**
**Ответ:**
-   **Пространство ядра (Kernel Space)**: Привилегированный режим, где работает ядро. Полный доступ к аппаратуре.
-   **Пользовательское пространство (User Space)**: Непривилегированный режим для приложений. Доступ к аппаратуре только через системные вызовы.

**Переход:** Системные вызовы (`syscalls`) → Прерывания (`int 0x80` или `syscall`).

---

## **2. Управление процессами и планирование**

### **Что такое процесс и поток?**
**Ответ:**
-   **Процесс**: Экземпляр программы с собственным адресным пространством, файловыми дескрипторами.
-   **Поток (thread)**: Легковесный процесс, разделяющий адресное пространство с другими потоками того же процесса.

**Реализация в Linux:** Потоки реализованы как процессы с общим адресным пространством (через `clone()` с флагом `CLONE_VM`).

### **Как работает планировщик (scheduler)?**
**Ответ:**
-   **CFS (Completely Fair Scheduler)**: Основной планировщик с версии 2.6.23. Работает на основе виртуального времени (`vruntime`). Старается公平分配 время CPU всем процессам.
-   **Приоритеты**: `nice` (от -20 до 19), `real-time` (SCHED_FIFO, SCHED_RR).

**Команды:**
```bash
chrt -p <PID>      # Посмотреть политику планирования
nice -n 10 command # Запустить с низким приоритетом
```

### **Что такое системные вызовы? Приведите примеры.**
**Ответ:** Интерфейс между пользовательским пространством и ядром.
-   `fork()`: Создать новый процесс.
-   `execve()`: Заменить образ процесса.
-   `open()`/`read()`/`write()`: Работа с файлами.
-   `mmap()`: Отобразить файл в память.

**Как посмотреть:** `strace -c <command>`

---

## **3. Управление памятью**

### **Как ядро управляет памятью?**
**Ответ:**
-   **Страничная память (Paging)**: Физическая память разбита на страницы (обычно 4 KiB). Виртуальные адреса переводятся в физические через Page Tables.
-   **MMU (Memory Management Unit)**: Аппаратный модуль, выполняющий трансляцию адресов.
-   **TLB (Translation Lookaside Buffer)**: Кеш MMU для ускорения трансляции.

### **Что такое OOM Killer?**
**Ответ:** Когда система исчерпывает память и swap, ядро принудительно убивает процесс-«нарушитель» на основе оценки `oom_score`.

**Диагностика:**
```bash
dmesg | grep -i oom
cat /proc/<PID>/oom_score
```

### **Что такое slab allocator?**
**Ответ:** Механизм кеширования часто используемых объектов ядра (например, дескрипторы файлов, структуры inode). Уменьшает фрагментацию и ускоряет выделение памяти.

**Просмотр:**
```bash
slabtop
```

---

## **4. Файловые системы**

### **Что такое VFS (Virtual File System)?**
**Ответ:** Абстрактный слой, который предоставляет единый интерфейс для работы с разными файловыми системами (ext4, XFS, Btrfs). Определяет общие структуры: `inode`, `dentry`, `file`.

### **Как работает открытие файла?**
**Ответ:**
1.  Пользовательский вызов `open("file.txt", O_RDONLY)`.
2.  Ядро ищет `dentry` в кеше.
3.  Если нет, обращается к ФС для поиска inode.
4.  Создает структуру `file` и возвращает файловый дескриптор.

### **Что такое inode?**
**Ответ:** Структура, хранящая метаданные файла (права, владелец, размер, указатели на данные). Не включает имя файла.

**Просмотр:**
```bash
stat file.txt
ls -i file.txt   # Показать номер inode
```

---

## **5. Сеть и безопасность**

### **Как работает сетевой стек?**
**Ответ:**
1.  **Аппаратный уровень**: Сетевая карта, прерывания.
2.  **Драйвер**: Обрабатывает пакеты, передает в стек.
3.  **Протоколы**: IP, TCP, UDP (обработка в ядре).
4.  **Сокеты**: Интерфейс для приложений.

**Инструменты:** `tcpdump`, `bpftrace`, `dropwatch`.

### **Что такое namespaces и cgroups?**
**Ответ:**
-   **Namespaces**: Изолируют ресурсы (PID, сеть, mount) для контейнеров.
    -   `unshare --pid --fork bash` # Создать новый PID namespace
-   **cgroups (Control Groups)**: Ограничивают использование ресурсов (CPU, память, I/O).
    -   `systemd-cgtop` # Просмотр cgroups

---

## **6. Модули ядра и отладка**

### **Как загрузить модуль ядра?**
**Ответ:**
```bash
insmod module.ko   # Простая загрузка
modprobe module    # Загрузка с учетом зависимостей
lsmod              # Список загруженных модулей
```

### **Как отлаживать ядро?**
**Ответ:**
-   **printk()**: Вывод в кольцевой буфер (`dmesg`).
-   **KGDB**: Отладка по сети.
-   **Ftrace**: Трассировка функций.
-   **BPF (eBPF)**: Динамическая трассировка и мониторинг.

**Пример Ftrace:**
```bash
echo function > /sys/kernel/debug/tracing/current_tracer
cat /sys/kernel/debug/tracing/trace_pipe
```

---

## **7. Практические задачи на собеседовании**

### **Задача 1: Посчитать количество процессов в системе**
**Решение:**
```bash
ps -e --no-headers | wc -l
# Или
find /proc -maxdepth 1 -type d -name '[0-9]*' | wc -l
```

### **Задача 2: Найти процесс, который использует больше всего памяти**
**Решение:**
```bash
ps -eo pid,ppid,cmd,%mem --sort=-%mem | head -n 5
```

### **Задача 3: Узнать, какой системный вызов делает процесс**
**Решение:**
```bash
strace -p <PID> -e trace=open,read,write
```

---

### **Чеклист для подготовки**
1.  **Повторите основные структуры ядра:** `task_struct`, `inode`, `file`.
2.  **Понимание механизмов:** Системные вызовы, прерывания, обработка страничных ошибок.
3.  **Практика:** Напишите простой модуль ядра (например, выводящий `Hello, World` при загрузке).
4.  **Инструменты:** `strace`, `ltrace`, `ftrace`, `perf`.
5.  **Читайте код ядра:** Начните с простых частей (например, `/kernel/sched/fair.c` для CFS).

---

### **Частые вопросы на собеседовании**
1.  **Чем отличается `fork()` от `vfork()`?**
    -   `vfork()` создает процесс без копирования таблиц страниц (родитель блокируется до вызова `execve()` или `exit()` ребенком).

2.  **Что такое Copy-on-Write (CoW)?**
    -   Механизм, при котором память копируется только при попытке записи. Используется в `fork()`.

3.  **Как работает `kmalloc()` vs `vmalloc()`?**
    -   `kmalloc()`: Выделяет непрерывную *физическую* память (для DMA, мелких объектов).
    -   `vmalloc()`: Выделяет непрерывную *виртуальную* память (физическая может быть fragmented).

4.  **Что такое softirq и tasklets?**
    -   **Softirq**: Отложенное прерывание для обработки в контексте ядра (сетевой стек, планировщик).
    -   **Tasklets**: Надстройка над softirq (более простой API).


## **Что такое `chroot`?**

**`chroot`** (от **ch**ange **root** — «сменить корневой каталог») — это системный вызов и одноименная утилита в Linux, которая изменяет корневой каталог (`/`) для текущего запущенного процесса и всех его дочерних процессов на указанный каталог в файловой системе.

Проще говоря, `chroot` «запирает» процесс в определенном каталоге, который становится для него новым корнем файловой системы. Процесс не может выйти за пределы этого каталога или получить доступ к файлам вне его.

---

### **Как это работает?**

До `chroot`:  
Файловая система процесса выглядит так:  
`/home/user/file.txt` → реальный путь на диске.

После `chroot /mnt/jail`:  
Теперь для процесса корень — это `/mnt/jail`.  
Попытка доступа к `/home/user/file.txt` будет преобразована в доступ к `/mnt/jail/home/user/file.txt`.  
Если файла `/mnt/jail/home/user/file.txt` не существует, процесс получит ошибку `ENOENT` («No such file or directory»), даже если реальный файл `/home/user/file.txt` существует.

---

### **Для чего используется `chroot`?**

1.  **Изоляция и безопасность (Примитивный «jail»)**:  
    - Исторически это был основной способ изоляции сервисов (например, `bind9`, `postfix`).  
    - Если злоумышленник взламывал изолированный сервис, он оказывался «в клетке» и не мог получить доступ к основной системе.  
    - **Важно:** `chroot` — это **НЕ** полноценная sandbox-изоляция. Она изолирует только файловую систему, но не процессы, сеть или другие ресурсы.

2.  **Восстановление системы**:  
    - Если система не загружается, можно загрузиться с LiveCD, смонтировать корневой раздел в `/mnt` и выполнить `chroot /mnt`. Это позволяет «войти» в сломанную систему и выполнить команды восстановления (переустановить загрузчик, исправить конфиги).

3.  **Создание и сборка пакетов**:  
    - Для сборки программных пакетов в чистой среде, чтобы избежать загрязнения зависимостями основной системы.  
    - Современные инструменты вроде `debootstrap` создают базовую систему в каталоге, которую затем можно использовать через `chroot`.

4.  **Тестирование и разработка**:  
    - Тестирование программ в разных окружениях (например, в старой версии дистрибутива).

---

### **Как использовать утилиту `chroot`?**

Синтаксис простой:
```bash
sudo chroot /path/to/new/root /bin/bash
```
-   `/path/to/new/root` — каталог, который станет новым корнем.
-   `/bin/bash` — команда (shell), которая будет запущена внутри этого нового окружения.

**ОЧЕНЬ ВАЖНЫЙ ШАГ:** Перед запуском `chroot` необходимо смонтировать виртуальные файловые системы (`/proc`, `/dev`, `/sys`) внутрь нового корня, чтобы команды внутри `chroot` могли нормально работать.

**Пример правильной настройки `chroot`-окружения:**
```bash
# Допустим, мы хотим сделать chroot в каталог /mnt/jail
# 1. Смонтируем виртуальные ФС внутрь jail
sudo mount -t proc /proc /mnt/jail/proc
sudo mount -t sysfs /sys /mnt/jail/sys
sudo mount --bind /dev /mnt/jail/dev
sudo mount --bind /dev/pts /mnt/jail/dev/pts

# 2. Копируем резолв конф (чтобы работал DNS внутри chroot)
sudo cp /etc/resolv.conf /mnt/jail/etc/resolv.conf

# 3. Выполняем chroot
sudo chroot /mnt/jail /bin/bash

# Теперь мы "внутри" jail. Команда `ls /` покажет файлы из /mnt/jail.
```

---

### **Ограничения и недостатки `chroot`**

1.  **Неполная изоляция**:  
    - Процесс видит всех остальных процессов системы (`ps aux` покажет всё).  
    - Сетевые интерфейсы общие.  
    - Можно сбежать из `chroot` привилегированному процессу (если есть root-доступ внутри `chroot` и есть уязвимости).

2.  **Сложность настройки**:  
    - Необходимо вручную копировать все необходимые библиотеки, бинарники и конфиги в `chroot`-окружение. Инструменты вроде `debootstrap` или `yum` упрощают эту задачу.

---

### **`chroot` vs. Современные контейнеры (Docker)**

Современные контейнеры (Docker, LXC) — это эволюция идеи `chroot`. Они используют `chroot` как один из многих механизмов изоляции, но добавляют к нему:
-   **Namespaces** (изоляция PID, сети, пользователей, IPC).
-   **Cgroups** (ограничение и учет ресурсов: CPU, память, I/O).
-   **Capabilities** (разделение привилегий root).
-   **Слоистые файловые системы** (UnionFS, OverlayFS).

По сути, **Docker-контейнер** — это продвинутый, удобный и безопасный `chroot` на стероидах.

---

### **Ключевые выводы**

*   **`chroot`** изменяет корневой каталог для процесса, изолируя его файловую систему.
*   Это полезный инструмент для **восстановления системы**, **примитивной изоляции сервисов** и **сборки пакетов**.
*   **Это не безопасная sandbox**! Для реальной изоляции используйте полноценные контейнеры (Docker) или виртуальные машины.
*   Для работы большинства программ внутри `chroot` необходимо предварительно смонтировать `/proc`, `/dev` и `/sys`.

Понимание `chroot` — это важный шаг к пониманию того, как работают современные контейнеры.