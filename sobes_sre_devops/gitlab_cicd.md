## 1. Базовые концепции и терминология

### **Вопрос: Что такое CI/CD? Объясните разницу между CI и CD.**

*   **CI (Continuous Integration)** — это практика частого слияния кода от всех разработчиков в общую главную ветку. Каждое слияние запускает автоматизированную сборку и тестирование, чтобы быстро выявлять ошибки.
    *   *Цель:* Обнаружить проблемы как можно раньше.
*   **CD (Continuous Delivery/Deployment)** — это автоматизация процесса развертывания приложения.
    *   **Continuous Delivery:** Код всегда находится в состоянии, готовом к развертыванию в production (релиз вручную).
    *   **Continuous Deployment:** Каждое изменение, прошедшее CI-пайплайн, автоматически развертывается в production (релиз автоматический).
*   **Итог:** CI — это про "строим и тестируем правильно", CD — про "развертываем быстро и безопасно".

### **Вопрос: Что такое GitLab CI/CD? Из каких основных компонентов оно состоит?**

*   Это встроенный инструмент в GitLab для автоматизации процессов сборки, тестирования и развертывания.
*   **Ключевые компоненты:**
    1.  **`.gitlab-ci.yml`** — файл в корне репозитория, где описывается весь пайплайн.
    2.  **GitLab Runner** — легковесное приложение, которое запускает jobs (задачи). Бывают shared, group-specific и project-specific.
    3.  **Pipeline** — цепочка этапов и jobs, которая запускается при коммите или по расписанию.
    4.  **Stages** — этапы пайплайна (например, `build`, `test`, `deploy`). Jobs в одном stage выполняются параллельно.
    5.  **Jobs** — отдельные задачи (например, `run-unit-tests`, `compile-app`), которые выполняют скрипты.
    6.  **Variables** — переменные для хранения настроек, ключей и т.д.

---

## 2. Структура и написание `.gitlab-ci.yml`

### **Вопрос: Опишите базовую структуру файла `.gitlab-ci.yml`.**

{% raw %}
```yaml
# Определение стадий (этапов) пайплайна в порядке выполнения
stages:
  - build
  - test
  - deploy

# Переменные, доступные для всех jobs
variables:
  IMAGE_TAG: "latest"

# Job 1: Сборка приложения
build-job:
  stage: build
  script:
    - echo "Собираем приложение..."
    - docker build -t my-app:$IMAGE_TAG .
  rules: # Правила запуска job
    - if: $CI_COMMIT_BRANCH == "main"

# Job 2: Запуск тестов
test-job:
  stage: test
  script:
    - echo "Запускаем тесты..."
    - docker run my-app:$IMAGE_TAG npm test
  needs: [build-job] # Зависимость: запустится только после завершения build-job

# Job 3: Деплой
deploy-job:
  stage: deploy
  script:
    - echo "Деплоим в production..."
    - ./deploy-prod.sh
  environment: production # Определение окружения для деплоя
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
```
{% endraw %}
**Ключевые моменты:** `stages`, `script`, `rules`, `needs`, `environment`.

### **Вопрос: В чем разница между `tags` и `image` в конфигурации job?**
*   **`image`** — определяет Docker-образ, который будет использован для создания контейнера, в котором запустится job (например, `image: node:16`).
*   **`tags`** — определяет, на каком **GitLab Runner** будет запущена job. Тэг runner'а должен совпадать с тэгом в job (например, `tags: [docker, aws]`). Это нужно для направления jobs на нужные машины (например, runner с установленным Kubernetes CLI для деплоя).

---

## 3. Управление выполнением пайплайна

### **Вопрос: Как можно контролировать, когда запускается job/pipeline? (``only``/``except`` vs ``rules``)**

*   Старые ключевые слова `only` и `except` устаревают. **`rules`** — это современный, более гибкий и мощный способ.
*   **`rules`** позволяют использовать условия `if`, `changes`, `exists`, а также управлять состоянием job (`when: on_success|on_failure|always|manual|delayed`).

**Пример `rules`:**
{% raw %}
```yaml
deploy-job:
  stage: deploy
  script: [...]
  rules:
    # Запускать вручную для main ветки
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: false
    # Не запускать для merge requests
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: never
    # Запускать для тегов, начинающихся с 'v'
    - if: $CI_COMMIT_TAG =~ /^v.*/
```
{% endraw %}
**Отличный знак:** Упоминание `$CI_PIPELINE_SOURCE` (событие, запустившее пайплайн: push, merge_request, schedule, api и т.д.).

### **Вопрос: Что такое `needs:` и зачем это нужно?**
*   Позволяет определять зависимости между jobs **из разных stages**.
*   **Зачем:** Позволяет избежать последовательного выполнения и создавать Directed Acyclic Graphs (DAG). Это значительно ускоряет пайплайн, так как jobs могут запускаться как только завершатся их зависимости, а не ждать всю stage.
*   **Пример:** Job деплоя на staging может `need` job сборки артефакта и job тестирования, которые выполняются параллельно.

---

## 4. Артефакты и кеширование

### **Вопрос: В чем разница между `cache` и `artifacts`?**
*   **`artifacts`** — используются для передачи файлов между jobs **в одном пайплайне**. Файлы загружаются в GitLab и могут быть скачаны через UI после завершения пайплайна. Например, скомпилированный JAR-файл из `build`-stage для `test`-stage.
*   **`cache`** — используется для ускорения последующих запусков пайплайна за счет сохранения промежуточных файлов (например, зависимостей `node_modules/` или `vendor/`). Кеш не гарантирует целостность и может быть не доступен в некоторых случаях (например, для разных веток).

---

## 5. Безопасность и лучшие практики

### **Вопрос: Где и как безопасно хранить секреты (пароли, ключи API, токены) в GitLab CI/CD?**
*   **Нельзя:** Хранить в `.gitlab-ci.yml` или в коде.
*   **Нужно:** Использовать **CI/CD Variables** в настройках проекта/группы.
    *   Можно задавать `Protected` (только для protected branches/tags) и `Masked` (значение скрыто в логах).
*   Для работы с облачными провайдерами (AWS, GCP, Azure) использовать **OIDC (OpenID Connect)**. Это современный и безопасный подход, который позволяет выдавать кратковременные credentials вместо долгоживущих ключей.
    *   *Пример для AWS:* `assume-role-with-web-identity`.
*   Для более сложных сценариев — использовать HashiCorp Vault с интеграцией через CI/CD Variables.

### **Вопрос: Какие best practices по написанию пайплайнов вы знаете?**
*   **Использовать `include`:** Разбивать большой `.gitlab-ci.yml` на несколько файлов для переиспользования конфигураций (например, общие шаблоны для деплоя).
*   **Использовать шаблоны (`extends`):** Чтобы избежать дублирования кода в jobs.
*   **Использовать `rules:`** вместо устаревших `only/except`.
*   **Оптимизировать кеширование:** Правильно настраивать `key` и `policy` для `cache`.
*   **Использовать `needs:`** для построения DAG и ускорения пайплайна.
*   **Определять `timeout`** для долгих jobs.
*   **Всегда использовать конкретные теги образов** (`image: node:16-alpine`), а не `latest`.
*   **Настраивать `retry`** для обработки временных сетевых сбоев.

---

## 6. Вопросы на проблему и решение (Troubleshooting)

### **Вопрос: Пайплайн падает с ошибкой "connection refused" на шаге деплоя в Kubernetes. С чего начнете искать проблему?**
*   **Подход:**
    1.  **Локальная проверка:** Запустить команды деплоя (`kubectl`, `helm`) локально с теми же параметрами. Работает ли?
    2.  **Runner:** Убедиться, что runner имеет тэг, который позволяет ему запускать job деплоя, и что на нем установлены нужные CLI-инструменты.
    3.  **Доступ к кластеру:** Проверить, правильно ли заданы переменные окружения (`KUBE_URL`, `KUBE_TOKEN` или `KUBE_CONFIG`). Не истек ли ли срок действия токена/сертификата?
    4.  **Сетевые правила:** Есть ли исходящий доступ с runner'а до API-сервера Kubernetes? Не блокирует ли его firewall?
    5.  **RBAC:** Имеет ли service account, от которого идет деплой, достаточно прав в кластере?
    6.  **Логи:** Включить более детальное логирование (`kubectl --v=9`) в скрипте, чтобы увидеть детали запроса.

### **Вопрос: Пайплайн стал выполняться очень долого. Как вы будете его оптимизировать?**
*   **Анализ:** Посмотреть через UI GitLab на график пайплайна и найти самые медленные jobs.
*   **Стратегии:**
    1.  **Кеширование зависимостей:** Правильно настроить `cache` для пакетных менеджеров (npm, pip, maven).
    2.  **Распараллеливание:** Разбить тяжелые тесты на несколько параллельных jobs с помощью `parallel` и стратегии `matrix`.
    3.  **Зависимости (`needs:`):** Запускать jobs как можно раньше, не дожидаясь всей stage.
    4.  **Образы:** Использовать минимальные базовые образы (Alpine) для ускорения их скачивания.
    5.  **Более мощные Runners:** Для ресурсоемких задач использовать более производительные машины.

---

## 7. Вопросы на архитектуру и дизайн

### **Вопрос: Как бы вы организовали пайплайн для приложения с микросервисной архитектурой?**
*   **Вариант 1 (простой):** Один репозиторий — один пайплайн для каждого микросервиса.
*   **Вариант 2 (монорепозиторий):** Один репозиторий для нескольких сервисов.
    *   Использовать `rules: changes:` для запуска пайплайна только того сервиса, файлы которого изменились.
    *   Использовать `include: local` для подключения общих конфигураций из того же репозитория.
    *   Настроить пайплайн для сборки и тестирования зависимых сервисов, если изменились общие библиотеки.

### **Вопрос: Как реализовать Canary или Blue-Green деплой через GitLab CI/CD?**
*   **Общая идея:** Использовать `manual` jobs с утверждением и скриптами, управляющими нагрузкой (например, через Kubernetes, Istio, или AWS ELB/ALB).
*   **Пример для Canary в k8s:**
    1.  Job `deploy-canary` (запускается вручную) развертывает 10% трафика на новую версию.
    2.  Job `pause` (автоматически с `when: manual`) ждет, пока кто-то проверит метрики (Prometheus/Grafana).
    3.  Если все OK, вручную запускается job `deploy-full`, который переводит на новую версию 100% трафика.
    4.  Если что-то не так, вручную запускается job `rollback`.

## Итоговая подготовка

1.  **Практика:** Создайте свой демо-проект и поэкспериментируйте. Напишите пайплайн с несколькими стадиями, используйте `needs`, `cache`, `artifacts`, `rules`.
2.  **Опыт:** Будьте готовы рассказать про свой реальный опыт: какой самый сложный пайплайн вы настраивали, с какими проблемами столкнулись и как их решили.
3.  **Термины:** Уверенно оперируйте терминами: Runner, Pipeline, Stage, Job, Artifact, Environment, Deployment.
4.  **Вопросы:** Всегда готовьте свои вопросы компании. Например: "Как у вас организована инфраструктура runner'ов?", "Какие практики безопасности для пайплайнов вы используете?".

